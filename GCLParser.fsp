// Open the file that defines the type "expr" we shall use as AST
%{
open GCDTypesAST
%}

// Declare the tokens (terminal symbols)
%token <int> NUM <String> VAR
%token SKIP SEMI IF FI DO OD ARROW LBRAC RBRAC TIMES DIV PLUS MINUS POW LPAR RPAR SQRT TRUE FALSE OR SCOR AND SCAND NUT EQUAL NEQ GT LT GEQ LEQ 
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
//%left PLUS MINUS
//%left TIMES DIV
//%right POW

// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <expr> start
%type <expr> c
%type <expr> gc 
%type <expr> a
%type <expr> b

%type <expr> expression
%type <expr> expression1
%type <expr> expression2
%type <expr> expression3

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: C EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for exps
// written in the yacc format:
//C -> x := a | A[a] := a | skip | C ; C | if GC fi | do G
    c:
  | VAR ASS a                     {AssExpr($1,$3)}
  | VAR LBRAC a RBRAC ASS a       {AssArrayExpr($1,$3,$6)}
  | SKIP                          {SkipExpr}
  | c SEMI c                      {SemiExpr($1,$3)}
  | IF gc FI                      {IfExpr($2)}
  | DO gc OD                      {DoExpr($2)}

//GC -> b -> C | GC [] GC
gc:
  |b ARROW c                      {ArrowExpr($1,$3)}        
  |gc IFELSE gc                   {IfElseExpr($1,$3)}


//a0 -> a0 + a1 | a0 - a1 | a1 
a:
  | a PLUS a1    { PlusExpr($1,$3) }
  | a MINUS a1   { MinusExpr($1,$3) }
  | a1                    { $1 }
//A1 -> A1 * A2 | A1 / A2 | A2
a1:
  | a1 TIMES a2   { TimesExpr($1,$3) }
  | a1 DIV a2     { DivExpr($1,$3) }
  | a2                     { $1 }
//E2 -> E2^E3
a2:
  | a2 POW a3     { PowExpr($1,$3) }
  | a3                     { $1 }
//E3 -> - E3 | + E3 | (E) | Num
a3:
  | PLUS a3              { UPlusExpr($2) }
  | MINUS a3             { UMinusExpr($2) }
  | NUM                  { Num($1) }
  | LPAR a RPAR          { $2 }



// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
